{"version":3,"sources":["../src/hooks/seasonUpdateHooks.ts","../src/hooks/seasonFetchHooks.ts","../firebaseConfig.ts","../src/hooks/matchupFetchHooks.ts","../src/constants/messages.ts","../src/hooks/playerFetchHooks.ts","../src/hooks/scheduleUpdateHooks.ts","../src/hooks/teamFetchHooks.ts","../src/hooks/teamToPlayerOperations.ts","../src/hooks/teamUpdateHooks.ts","../src/hooks/useAuth.ts","../src/Auth.ts"],"sourcesContent":["// ------------------------------\n// TABLE OF CONTENTS\n// ------------------------------\n// 1. Hooks\n//    - useAddOrUpdateSeason\n// 2. FireBaseFunctions\n//    - addOrUpdateSeasonRQ\n\n//------------------------\n// IMPORTS\n//------------------------\n\n// react query\nimport { useMutation } from 'react-query';\nimport { fetchSeasonRQ } from './seasonFetchHooks';\n\n// firebase\nimport { db } from '../../firebaseConfig';\nimport { updateDoc, doc, setDoc } from 'firebase/firestore';\n\n// types\nimport { Season } from '../types/seasonTypes';\nimport { SeasonName } from '../types/sharedTypes';\n\n// ------------------------------\n// 1. HOOKS\n// ------------------------------\n\nexport const useAddSeason = () => {\n  const mutation = useMutation(addSeasonRQ);\n\n  const addSeason = async (seasonName: string, seasonData: Season) => {\n    mutation.mutate({ seasonName, seasonData });\n  };\n\n  return { addSeason, ...mutation };\n};\n\nexport const useUpdateSeason = () => {\n  return useMutation(updateSeasonRQ);\n};\n\n// ------------------------------\n// 2. FIREBASE FUNCTIONS\n// ------------------------------\n\n/**\n * Adds a new season document to Firestore.\n *\n * @param seasonName - The name of the season to add.\n * @param seasonData - The season data object to add.\n */\nexport const addSeasonRQ = async ({\n  seasonName,\n  seasonData,\n}: {\n  seasonName: SeasonName;\n  seasonData: Season;\n}) => {\n  const seasonRef = doc(db, 'seasons', seasonName);\n  await setDoc(seasonRef, { ...seasonData, seasonCompleted: false });\n};\n\n/**\n * Updates an existing season document in Firestore.\n *\n * @param seasonName - The name of the season to update.\n * @param seasonData - The partial season data to update.\n */\nexport const updateSeasonRQ = async ({\n  seasonName,\n  seasonData,\n}: {\n  seasonName: SeasonName;\n  seasonData: Partial<Season>;\n}) => {\n  const seasonRef = doc(db, 'seasons', seasonName);\n  await updateDoc(seasonRef, seasonData);\n};\n\nconst checkSeasonExists = async (seasonName: SeasonName): Promise<boolean> => {\n  try {\n    const season = await fetchSeasonRQ(seasonName);\n    return Boolean(season);\n  } catch (error) {\n    return false;\n  }\n};\n","// ------------------------------\n// TABLE OF CONTENTS\n// ------------------------------\n// 1. Hooks\n//    - useFetchSeasons\n//    - useFetchSeason\n// 2. FireBaseFunctions\n//    - fetchSeasonsRQ\n//    - fetchSeasonRQ\n\n//------------------------\n// IMPORTS\n//------------------------\n\n// react query\nimport { useQuery, useQueryClient } from 'react-query';\n\n// firebase\nimport { db } from '../../firebaseConfig';\nimport {\n  collection,\n  query,\n  where,\n  getDocs,\n  doc,\n  getDoc,\n} from 'firebase/firestore';\n\n// types\nimport { Season } from '../types/seasonTypes';\nimport { SeasonName } from '../types/sharedTypes';\n\n// ------------------------------\n// 1. HOOKS\n// ------------------------------\n\nexport const useFetchSeasons = () => {\n  const queryClient = useQueryClient();\n\n  const refetchSeasons = () => {\n    queryClient.invalidateQueries('seasons');\n  };\n  return { ...useQuery('currentSeasons', fetchSeasonsRQ), refetchSeasons };\n};\n\nexport const useFetchSeason = (seasonName: string) => {\n  return useQuery(['season', seasonName], () => fetchSeasonRQ(seasonName));\n};\n\n// ------------------------------\n// 2. FIREBASE FUNCTIONS\n// ------------------------------\n\n/**\n * Fetches ALL seasons from Firestore where seasonCompleted = false.\n *\n * Queries seasons collection filtered by seasonCompleted field.\n * Maps results to Season objects by extracting id and data.\n *\n * Returns Promise resolving to array of Season objects.\n */\n\nconst fetchSeasonsRQ = async (): Promise<Season[]> => {\n  const seasonQuery = query(\n    collection(db, 'seasons'),\n    where('seasonCompleted', '==', false)\n  );\n  const querySnapshot = await getDocs(seasonQuery);\n\n  const seasonsArray = querySnapshot.docs.map((doc) => {\n    const season = doc.data();\n    season.id = doc.id;\n    return season as Season;\n  });\n\n  return seasonsArray;\n};\n\n/**\n * Fetches a SINGLE season by name/id from Firestore.\n *\n * Takes a season name/id string.\n * Gets the season document reference by name.\n * Fetches the season document snapshot.\n * If found, returns a Season object from the snapshot data.\n * If not found, throws an error.\n */\n\nexport const fetchSeasonRQ = async (\n  seasonName: SeasonName | undefined\n): Promise<Season> => {\n  if (seasonName === undefined) {\n    throw new Error('Season name/id not provided');\n  }\n  const seasonDoc = doc(db, 'seasons', seasonName);\n  const seasonDocSnapshot = await getDoc(seasonDoc);\n  if (seasonDocSnapshot.exists()) {\n    const season = seasonDocSnapshot.data();\n    season.id = seasonDocSnapshot.id;\n    return season as Season;\n  } else {\n    throw new Error('Season not found');\n  }\n};\n","import { initializeApp } from 'firebase/app';\nimport { getFirestore } from 'firebase/firestore';\nimport { getAuth } from 'firebase/auth';\n\nconst firebaseConfig = {\n  /* cSpell:disable */\n  apiKey: 'AIzaSyC5MvMfEeebh3XxyzYSD3qWpFR0aAAXSHM',\n  authDomain: 'expo-bca-app.firebaseapp.com',\n  databaseURL: 'https://expo-bca-app-default-rtdb.firebaseio.com',\n  projectId: 'expo-bca-app',\n  storageBucket: 'expo-bca-app.appspot.com',\n  messagingSenderId: '248104656807',\n  appId: '1:248104656807:web:853cad16b8fa38dbee2082',\n  measurementId: 'G-EL12CDVSCR',\n};\n\nconst app = initializeApp(firebaseConfig);\nconst db = getFirestore(app);\nconst auth = getAuth(app);\n\nexport { db, auth };\n","// ------------------------------\n// TABLE OF CONTENTS\n// ------------------------------\n// 1. Hooks\n//    - useFetchRoundRobin\n//    - useFetchFinishedRoundRobin\n// 2. FireBaseFunctions\n//    - fetchRoundRobinRQ\n//    - fetchFinishedRoundRobinRQ\n\n//------------------------\n// IMPORTS\n//------------------------\n\n// react query\nimport { useQuery } from 'react-query';\n\n// firebase\nimport { db } from '../../firebaseConfig';\nimport { doc, getDoc } from 'firebase/firestore';\n\n// types\nimport { SeasonName } from '../types/sharedTypes';\n\nimport {\n  RoundRobinSchedule,\n  RoundRobinScheduleFinished,\n} from '../types/matchupTypes';\nimport { notFound } from '../constants/messages';\n\n// ------------------------------\n// 1. HOOKS\n// ------------------------------\n\nexport const useFetchRoundRobin = (numberOfTeams: number | undefined) => {\n  return useQuery(\n    ['roundRobin', numberOfTeams],\n    () => fetchRoundRobinRQ(numberOfTeams),\n    { enabled: !!numberOfTeams }\n  );\n};\n\nexport const useFetchFinishedRoundRobin = (\n  seasonName: SeasonName | undefined\n) => {\n  return useQuery(\n    ['roundRobinFinished', seasonName],\n    () => fetchFinishedRoundRobinRQ(seasonName),\n    { enabled: !!seasonName }\n  );\n};\n\n// ------------------------------\n// 2. FIREBASE FUNCTIONS\n// ------------------------------\n\n/**\n * Adjusts the number of teams to be valid for generating a round robin schedule.\n *\n * - Ensures number of teams is even by adding 1 if odd.\n * - Sets number to minimum of 4 teams.\n * - Throws error if more than 48 teams.\n *\n * @param numberOfTeams - Original number of teams\n * @returns Adjusted number of teams valid for round robin schedule.\n */\nconst adjustNumberOfTeams = (numberOfTeams: number) => {\n  let adjustedNumber = numberOfTeams;\n  if (numberOfTeams % 2 !== 0) {\n    adjustedNumber += 1;\n  }\n  if (numberOfTeams < 4) {\n    adjustedNumber = 4;\n  }\n  if (numberOfTeams > 48) {\n    throw new Error(\n      'Round Robin Schedule for more than 48 teams not supported'\n    );\n  }\n  return adjustedNumber;\n};\n\n/**\n * Fetches a round robin schedule from Firestore for the given number of teams.\n *\n * Adjusts the number of teams to be valid for round robin generation.\n * Looks up the schedule by the adjusted team name in Firestore.\n * Returns the schedule if found, else throws an error.\n */\nconst fetchRoundRobinRQ = async (\n  numberOfTeams: number | undefined\n): Promise<RoundRobinSchedule | null> => {\n  if (numberOfTeams === undefined) {\n    throw new Error('Number of teams not provided');\n  }\n  const adjustedTeams = adjustNumberOfTeams(numberOfTeams);\n  const scheduleName = `scheduleFor${adjustedTeams}Teams`;\n  const scheduleRef = doc(db, 'roundRobinSchedules', scheduleName);\n  const scheduleDoc = await getDoc(scheduleRef);\n  if (scheduleDoc.exists()) {\n    return scheduleDoc.data() as RoundRobinSchedule;\n  } else {\n    throw new Error(\n      `Round Robin Schedule for ${adjustedTeams} teams ${notFound}`\n    );\n  }\n};\n\n/**\n * Fetches a finished round robin schedule from Firestore for the given season ID.\n *\n * Looks up the schedule by season ID in the 'finishedRoundRobinSchedules' collection.\n * Returns the schedule if found, else throws an error.\n */\nconst fetchFinishedRoundRobinRQ = async (\n  seasonId: SeasonName | undefined\n): Promise<RoundRobinScheduleFinished | null> => {\n  if (seasonId === undefined) {\n    throw new Error('Season ID not provided');\n  }\n  const scheduleRef = doc(db, 'finishedRoundRobinSchedules', seasonId);\n  const scheduleDoc = await getDoc(scheduleRef);\n  if (scheduleDoc.exists()) {\n    return scheduleDoc.data() as RoundRobinScheduleFinished;\n  } else {\n    throw new Error(\n      `Finished Round Robin Schedule for ${seasonId} ${notFound}`\n    );\n  }\n};\n","// common texts for failed and successful requests.\nexport const failedFetch = 'Failed to fetch ';\nexport const failedUpdate = 'Failed to update ';\nexport const failedCreate = 'Failed to create ';\nexport const tryAgain = 'Please try again. ';\nexport const createSuccess = ' created successfully! ';\nexport const updateSuccess = ' successfully updated!';\nexport const notFound = ' not found in Firestore.';\nexport const deleteSuccess = 'Successfully removed ';\nexport const deleteFailed = 'Failed to remove ';\nexport const fromStore = ' from Firestore.';\nexport const toStore = ' to Firestore.';\n","// ------------------------------\n// TABLE OF CONTENTS\n// ------------------------------\n// 1. Hooks\n//    - useFetchPastPlayerById\n//    - useFetchCurrentUserById\n//    - useFetchPastPlayers\n//    - useFetchCurrentUsers\n// 2. FireBaseFunctions\n//    - fetchPastPlayerByIdRQ\n//    - fetchCurrentUserById\n//    - fetchAllPastPlayersRQ\n//    - fetchAllCurrentUsers\n\n//------------------------\n// IMPORTS\n//------------------------\nimport { useQuery } from 'react-query';\nimport { db } from '../../firebaseConfig';\nimport { collection, doc, getDoc, getDocs } from 'firebase/firestore';\nimport { Email } from '../types/sharedTypes';\nimport { CurrentUser, PastPlayer } from '../types/userTypes';\n\n// ------------------------------\n// 1. HOOKS\n// ------------------------------\n\nexport const useFetchPastPlayerById = (playerId: Email | undefined) => {\n  return useQuery(\n    ['pastPlayer', playerId],\n    () => fetchPastPlayerByIdRQ(playerId),\n    {\n      enabled: !!playerId,\n    }\n  );\n};\nexport const useFetchCurrentUserById = (id: string | undefined) => {\n  return useQuery(['currentUser', id], () => fetchCurrentUserById(id), {\n    enabled: !!id,\n  });\n};\n\nexport const useFetchPastPlayers = () => {\n  return useQuery('pastPlayers', fetchAllPastPlayersRQ);\n};\n\nexport const useFetchCurrentUsers = () => {\n  return useQuery('currentUsers', fetchAllCurrentUsersRQ);\n};\n\n// ------------------------------\n// 2. FIREBASE FUNCTIONS\n// ------------------------------\n\n/**\n * Fetches a PastPlayer object by ID from Firestore.\n *\n * @param playerId - The ID of the past player to fetch.\n * @returns A Promise resolving to the PastPlayer object if found, or null if not found.\n * @throws Error if ID is not provided.\n */\nexport const fetchPastPlayerByIdRQ = async (\n  playerId: Email | undefined\n): Promise<PastPlayer | null> => {\n  if (playerId === undefined) {\n    throw new Error('Player ID not provided');\n  }\n  const playerDoc = doc(db, 'pastPlayers', playerId);\n  const playerDocSnapshot = await getDoc(playerDoc);\n  if (playerDocSnapshot.exists()) {\n    return {\n      id: playerDocSnapshot.id as Email,\n      ...(playerDocSnapshot.data() as Omit<PastPlayer, 'id'>),\n    };\n  } else {\n    throw new Error('Player not found');\n  }\n};\n\n/**\n * Fetches a CurrentUser object by ID from Firestore.\n *\n * @param id - The ID of the user to fetch.\n * @returns A Promise resolving to the CurrentUser object if found, or null if not found.\n * @throws Error if ID is not provided.\n */\nexport const fetchCurrentUserById = async (\n  id: string | undefined\n): Promise<CurrentUser | null> => {\n  if (id === undefined) {\n    throw new Error('User ID not provided');\n  }\n  const userDoc = doc(db, 'currentUsers', id as string);\n  const userDocSnapshot = await getDoc(userDoc);\n\n  if (userDocSnapshot.exists()) {\n    return {\n      id: userDocSnapshot.id,\n      ...(userDocSnapshot.data() as Omit<CurrentUser, 'id'>),\n    };\n  } else {\n    throw new Error('User not found');\n  }\n};\n\n/**\n * Fetches all PastPlayer objects from Firestore.\n *\n * @returns Promise resolving to an array of all PastPlayer objects.\n */\nconst fetchAllPastPlayersRQ = async (): Promise<PastPlayer[]> => {\n  const querySnapshot = await getDocs(collection(db, 'pastPlayers'));\n  const playersData: PastPlayer[] = [];\n\n  querySnapshot.forEach((doc) => {\n    const playerData = doc.data() as PastPlayer;\n    playersData.push({\n      ...playerData,\n      id: doc.id as Email,\n    });\n  });\n\n  return playersData;\n};\n\n/**\n * Fetches all CurrentUser objects from Firestore.\n *\n * @returns Promise resolving to an array of all CurrentUser objects.\n */\nconst fetchAllCurrentUsersRQ = async (): Promise<CurrentUser[]> => {\n  const querySnapshot = await getDocs(collection(db, 'currentUsers'));\n  const usersData: CurrentUser[] = [];\n\n  querySnapshot.forEach((doc) => {\n    const userData = doc.data() as CurrentUser;\n    usersData.push({\n      ...userData,\n      id: doc.id,\n    });\n  });\n\n  return usersData;\n};\n","// ------------------------------\n// TABLE OF CONTENTS\n// ------------------------------\n// 1. Hooks\n//    - useUpdateSeasonSchedule\n// 2. FireBaseFunctions\n//    - updateSeasonScheduleRQ\n\n//------------------------\n// IMPORTS\n//------------------------\n\n// react-query\nimport { useMutation } from 'react-query';\n\n// firebase\nimport { db } from '../../firebaseConfig';\nimport { updateDoc, doc } from 'firebase/firestore';\n\n//types\nimport { Schedule } from '../types/seasonTypes';\nimport { SeasonName } from '../types/sharedTypes';\n\n// ------------------------------\n// 1. HOOKS\n// ------------------------------\n\nexport const useUpdateSeasonSchedule = () => {\n  return useMutation(updateSeasonScheduleRQ);\n};\n\n// ------------------------------\n// 2. FIREBASE FUNCTIONS\n// ------------------------------\n/**\n * Updates the schedule for the given season in Firestore.\n *\n * @param seasonName - The name of the season document to update.\n * @param schedule - The updated schedule object to save.\n */\n\nexport const updateSeasonScheduleRQ = async ({\n  seasonName,\n  schedule,\n}: {\n  seasonName: SeasonName;\n  schedule: Schedule;\n}) => {\n  //reference to the season document\n  const seasonRef = doc(db, 'seasons', seasonName);\n  await updateDoc(seasonRef, {\n    schedule: schedule,\n  });\n};\n","// ------------------------------\n// TABLE OF CONTENTS\n// ------------------------------\n// 1. Hooks\n//    - useFetchTeamById\n//    - useFetchTeamsFromSeason\n// 2. FireBaseFunctions\n//    - fetchTeamByIdRQ\n//    - fetchTeamsFromSeasonRQ\n\n//------------------------\n// IMPORTS\n//------------------------\n\n// react query\nimport { useQuery, UseQueryOptions } from 'react-query';\nimport { fetchSeasonRQ } from './seasonFetchHooks';\n\n// firebase\nimport { db } from '../../firebaseConfig';\nimport { doc, getDoc } from 'firebase/firestore';\n\n// types\nimport { SeasonName } from '../types/sharedTypes';\nimport { Team } from '../types/teamTypes';\n\n// ------------------------------\n// 1. HOOKS\n// ------------------------------\n\nexport const useFetchTeamById = (teamId: string | undefined) => {\n  return useQuery(['team', teamId], () => fetchTeamByIdRQ(teamId), {\n    enabled: teamId !== undefined,\n  });\n};\n\nexport const useFetchTeamsFromSeason = (seasonName: SeasonName | undefined) => {\n  const query = useQuery<Team[], unknown>(\n    ['teamsFromSeason', seasonName],\n    () => fetchTeamsFromSeasonRQ(seasonName),\n    {\n      enabled: !!seasonName,\n    }\n  );\n  return query;\n};\n\n// ------------------------------\n// 2. FIREBASE FUNCTIONS\n// ------------------------------\n\n/**\n * Fetches a team by ID from Firestore.\n *\n * Takes a team ID string.\n * Gets the team document reference by ID.\n * Fetches the team document snapshot.\n * If found, returns a Team object from the snapshot data.\n * If not found, throws an error.\n */\n\nexport const fetchTeamByIdRQ = async (\n  teamId: string | undefined\n): Promise<Team | null> => {\n  if (teamId === undefined) {\n    throw new Error('Team ID not provided');\n  }\n  const teamDoc = doc(db, 'teams', teamId);\n  const teamDocSnapshot = await getDoc(teamDoc);\n  if (teamDocSnapshot.exists()) {\n    const teamData = teamDocSnapshot.data() as Team;\n    teamData.id = teamDocSnapshot.id;\n    return teamData;\n  } else {\n    throw new Error('Team not found');\n  }\n};\n\n/**\n * Fetches all teams for a given season from Firestore.\n *\n * Takes a season name/id string.\n * Gets the season document.\n * Maps over the season's team IDs to fetch each team document.\n * Awaits all team fetch promises.\n * Filters out any null teams.\n * Returns the array of Team objects.\n */\n\nconst fetchTeamsFromSeasonRQ = async (\n  seasonName: SeasonName | undefined\n): Promise<Team[]> => {\n  const seasonDoc = await fetchSeasonRQ(seasonName);\n  if (!seasonDoc.teams || seasonDoc.teams.length === 0) {\n    return [];\n  }\n  const teamsPromises = seasonDoc.teams.map(async (teamId) =>\n    fetchTeamByIdRQ(teamId)\n  );\n  const teams = await Promise.all(teamsPromises);\n  return teams.filter((team) => team !== null) as Team[];\n};\n","// ------------------------------\n// TABLE OF CONTENTS\n// ------------------------------\n// 1. Hooks\n//    - usePlayerToTeam ***THIS IS THE MAIN ONE TO USE\n//    - useAddTeamToBothViaPlayer\n//    - useAddTeamToBothViaUser\n//    - useRemoveTeamFromBothViaPlayer\n//    - useRemoveTeamFromBothViaUser\n// 2. Utilities\n//    - addTeamToPastPlayer\n//    - addTeamToCurrentUser\n//    - addTeamToBothWithPlayer\n//    - addTeamToBothWithUser\n//    - removeTeamFromPastPlayer\n//    - removeTeamFromCurrentUser\n//    - removeTeamFromBothWithPlayer\n//    - removeTeamFromBothWithUser\n//    - addPlayerToTeamRQ\n//    - insertPlayerOntoTeam\n//    - removeAllPlayersFromTeamRQ\n\n//------------------------\n// IMPORTS\n//------------------------\n\n// react query\nimport { useMutation } from 'react-query';\nimport { fetchTeamByIdRQ } from './teamFetchHooks';\nimport {\n  fetchCurrentUserById,\n  fetchPastPlayerByIdRQ,\n} from './playerFetchHooks';\n\n// firebase\nimport { db } from '../../firebaseConfig';\nimport {\n  doc,\n  updateDoc,\n  getDoc,\n  arrayUnion,\n  arrayRemove,\n  runTransaction,\n} from 'firebase/firestore'; // Import getFirestore from Firebase\n\n// types\nimport { TeamId, Email, PlayerId } from '../types/sharedTypes';\nimport { TeamPlayerRole, TeamPlayer, Team } from '../types/teamTypes';\n\n/**\n * Hook to add a player to a team.\n * On success, logs a message.\n * On error, logs a message.\n * @returns The mutation function to add a player to a team.\n */\nexport const useAddPlayerToTeam = () => {\n  return useMutation(addPlayerToTeamRQ, {\n    onSuccess: () => {\n      console.log('success');\n    },\n    onError: () => {\n      console.log('error');\n    },\n    retry: false,\n  });\n};\n\n/**\n * Hook to add a team to both currentPlayer and pastPlayer.\n * On success, logs a message.\n * On error, logs a message.\n * @returns The mutation function to add a team to both player teams.\n */\nexport const useAddTeamToBothViaPlayer = () => {\n  return useMutation(addTeamToBothWithPlayer, {\n    onSuccess: () => {\n      console.log('success');\n    },\n    onError: () => {\n      console.log('error');\n    },\n    retry: false,\n  });\n};\n\n/**\n * Hook to add a team to both currentPlayer and pastPlayer.\n * On success, logs a message.\n * On error, logs a message.\n * @returns The mutation function to add a team to both player teams.\n */\nexport const useAddTeamToBothViaUser = () => {\n  return useMutation(addTeamToBothWithUser, {\n    onSuccess: () => {\n      console.log('success');\n    },\n    onError: () => {\n      console.log('error');\n    },\n    retry: false,\n  });\n};\n\n/**\n * Hook to remove a team from both currentPlayer and pastPlayer.\n * On success, logs a message.\n * On error, logs a message.\n * @returns The mutation function to remove a team from both player teams.\n */\nexport const useRemoveTeamFromBothViaPlayer = () => {\n  return useMutation(removeTeamFromBothWithPlayer, {\n    onSuccess: () => {\n      console.log('success');\n    },\n    onError: () => {\n      console.log('error');\n    },\n    retry: false,\n  });\n};\n\n/**\n * Hook to remove a team from both currentPlayer and pastPlayer.\n * On success, logs a message.\n * On error, logs a message.\n * @returns The mutation function to remove a team from both player teams.\n */\nexport const useRemoveTeamFromBothViaUser = () => {\n  return useMutation(removeTeamFromBothWithUser, {\n    onSuccess: () => {\n      console.log('success');\n    },\n    onError: () => {\n      console.log('error');\n    },\n    retry: false,\n  });\n};\n\n/**\n * Adds a team ID to the 'teams' array field of a past player document.\n * @param teamId - The ID of the team to add.\n * @param pastPlayerId - The ID (email address) of the past player document to update.\n */\nconst addTeamToPastPlayer = async (teamId: TeamId, pastPlayerId: Email) => {\n  const playerRef = doc(db, 'pastPlayers', pastPlayerId as Email);\n  await updateDoc(playerRef, {\n    teams: arrayUnion(teamId as TeamId),\n  });\n};\n\n/**\n * Adds a team ID to the 'teams' array field of a current user document.\n *\n * @param teamId - The ID of the team to add\n * @param currentUserId - The ID of the current user document to update\n */\nconst addTeamToCurrentUser = async (\n  teamId?: TeamId,\n  currentUserId?: PlayerId\n) => {\n  if (!teamId || !currentUserId)\n    throw new Error('Missing teamId or currentUserId');\n  const userRef = doc(db, 'currentUsers', currentUserId as PlayerId);\n  await updateDoc(userRef, {\n    teams: arrayUnion(teamId as TeamId),\n  });\n};\n\n/**\n * Adds a team ID to the 'teams' array field of both a past player document and current user document,\n * by looking up the current user ID associated with the past player ID.\n *\n * @param teamId - The ID of the team to add\n * @param pastPlayerId - The ID (email address) of the past player document\n */\nconst addTeamToBothWithPlayer = async (\n  teamId?: TeamId,\n  pastPlayerId?: Email\n) => {\n  if (!teamId || !pastPlayerId)\n    throw new Error('Missing teamId or pastPlayerId');\n  await addTeamToPastPlayer(teamId, pastPlayerId);\n  const pastPlayer = await fetchPastPlayerByIdRQ(pastPlayerId as Email);\n  if (pastPlayer && pastPlayer.currentUserId) {\n    await addTeamToCurrentUser(teamId, pastPlayer.currentUserId);\n  }\n};\n\n/**\n * Adds a team ID to the 'teams' array field of both a current user document and associated past player document.\n * Looks up the past player ID associated with the current user ID.\n *\n * @param teamId - The ID of the team to add\n * @param currentUserId - The ID of the current user document\n */\nconst addTeamToBothWithUser = async (\n  teamId?: TeamId,\n  currentUserId?: PlayerId\n) => {\n  if (!teamId || !currentUserId)\n    throw new Error('Missing teamId or currentUserId');\n  await addTeamToCurrentUser(teamId, currentUserId);\n  const user = await fetchCurrentUserById(currentUserId as PlayerId);\n  if (user && user.pastPlayerId) {\n    await addTeamToPastPlayer(teamId, user.pastPlayerId);\n  }\n};\n\n/**\n * Removes a team ID from the 'teams' array field of a past player document.\n *\n * @param teamId - The ID of the team to remove\n * @param pastPlayerId - The ID (email address) of the past player document\n */\nconst removeTeamFromPastPlayer = async (\n  teamId?: TeamId,\n  pastPlayerId?: Email\n) => {\n  if (!teamId || !pastPlayerId)\n    throw new Error('Missing teamId or pastPlayerId');\n  const playerRef = doc(db, 'pastPlayers', pastPlayerId as Email);\n  await updateDoc(playerRef, {\n    teams: arrayRemove(teamId as TeamId),\n  });\n};\n/**\n * Removes a team ID from the 'teams' array field of a current user document.\n *\n * @param teamId - The ID of the team to remove\n * @param currentUserId - The ID of the current user document\n */\n\nconst removeTeamFromCurrentUser = async (\n  teamId?: TeamId,\n  currentUserId?: PlayerId\n) => {\n  if (!teamId || !currentUserId)\n    throw new Error('Missing teamId or currentUserId');\n  const userRef = doc(db, 'currentUsers', currentUserId as PlayerId);\n  await updateDoc(userRef, {\n    teams: arrayRemove(teamId as TeamId),\n  });\n};\n\n/**\n * Removes a team from both a past player and their associated current user, if found.\n *\n * @param teamId - The ID of the team to remove\n * @param pastPlayerId - The ID (email address) of the past player\n */\nconst removeTeamFromBothWithPlayer = async (\n  teamId?: TeamId,\n  pastPlayerId?: Email\n) => {\n  if (!teamId || !pastPlayerId)\n    throw new Error('Missing teamId or pastPlayerId');\n  await removeTeamFromPastPlayer(teamId, pastPlayerId);\n  const pastPlayer = await fetchPastPlayerByIdRQ(pastPlayerId as Email);\n  if (pastPlayer && pastPlayer.currentUserId) {\n    await removeTeamFromCurrentUser(teamId, pastPlayer.currentUserId);\n  }\n};\n\n/**\n * Removes a team from both a current user and their associated past player, if found.\n *\n * @param teamId - The ID of the team to remove\n * @param currentUserId - The ID of the current user\n */\nconst removeTeamFromBothWithUser = async (\n  teamId?: TeamId,\n  currentUserId?: PlayerId\n) => {\n  if (!teamId || !currentUserId)\n    throw new Error('Missing teamId or currentUserId');\n  await removeTeamFromCurrentUser(teamId, currentUserId);\n  const user = await fetchCurrentUserById(currentUserId as PlayerId);\n  if (user && user.pastPlayerId) {\n    await removeTeamFromPastPlayer(teamId, user.pastPlayerId);\n  }\n};\n\n/**\n * Adds a player to a team by:\n * 1. Fetching the team data\n * 2. Removing the team from the old player in that role\n * 3. Inserting the new player data into the team\n * 4. Adding the team to the new player\n * 5. Handling errors\n */\nconst addPlayerToTeamRQ = async ({\n  teamId,\n  role,\n  playerData,\n}: {\n  teamId: TeamId;\n  role: TeamPlayerRole;\n  playerData: TeamPlayer;\n}) => {\n  // Fetch the team data\n\n  const teamData = await fetchTeamByIdRQ(teamId);\n  if (!teamData) {\n    throw new Error('Team not found');\n  }\n  // get the player currently in the role on that team\n  const oldPlayer = teamData?.players[role];\n  // remove the team from the old player documents\n  if (oldPlayer.email) {\n    await removeTeamFromBothWithPlayer(teamId, oldPlayer.email);\n  } else if (oldPlayer.currentUserId) {\n    await removeTeamFromBothWithUser(teamId, oldPlayer.currentUserId);\n  }\n  try {\n    // insert playerData into team document\n    await insertPlayerOntoTeam(teamId, role, playerData);\n\n    // if successful add the team to the player documents\n    await addTeamToBothWithPlayer(teamId, playerData.email);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(error.message);\n    } else {\n      throw new Error('Unknown error');\n    }\n  }\n};\n\n/**\n * Inserts a player into a specific role on a team by:\n * - Getting the team document reference\n * - Retrieving the current team data\n * - Updating the team data with the new player in the specified role\n * - Writing the updated team data back to the database\n */\nconst insertPlayerOntoTeam = async (\n  teamId: TeamId,\n  role: TeamPlayerRole,\n  playerData: TeamPlayer\n) => {\n  const teamRef = doc(db, 'teams', teamId);\n  const teamDoc = await getDoc(teamRef);\n  if (teamDoc.exists()) {\n    const teamData = teamDoc.data() as Team;\n    const newTeamData = {\n      ...teamData,\n      players: {\n        ...teamData.players,\n        [role]: playerData,\n      },\n    };\n    await updateDoc(teamRef, newTeamData);\n  }\n};\n\n/**\n * Removes all players from a team by:\n * 1. Getting the team document.\n * 2. Getting the player IDs from the team document.\n * 3. Looping through each player ID:\n *   3a. Get the pastPlayer document.\n *   3b. Remove the team ID from the pastPlayer's teams array.\n *   3c. If the pastPlayer has a currentUserId, get that document.\n *   3d. Remove the team ID from the currentUser's teams array.\n *\n * This is done in a transaction to ensure consistency.\n */\n\nexport const removeAllPlayersFromTeamRQ = async (teamId: TeamId) => {\n  await runTransaction(db, async (transaction) => {\n    const teamRef = doc(db, 'teams', teamId);\n    const teamDoc = await transaction.get(teamRef);\n    if (!teamDoc.exists()) {\n      throw new Error('Team not found');\n    }\n\n    const teamData = teamDoc.data() as Team;\n    const playerIds = Object.values(teamData.players)\n      .map((player) => player.pastPlayerId)\n      .filter((pastPlayerId) => pastPlayerId);\n\n    for (const pastPlayerId of playerIds) {\n      const pastPlayerRef = doc(db, 'pastPlayers', pastPlayerId);\n      const pastPlayerDoc = await transaction.get(pastPlayerRef);\n      const pastPlayerData = pastPlayerDoc.data();\n\n      // Update the pastPlayer document\n      transaction.update(pastPlayerRef, {\n        teams: arrayRemove(teamId),\n      });\n\n      // If there is an associated current user, update that document too\n      if (pastPlayerData?.currentUserId) {\n        const currentUserRef = doc(\n          db,\n          'currentUsers',\n          pastPlayerData.currentUserId\n        );\n        transaction.update(currentUserRef, {\n          teams: arrayRemove(teamId),\n        });\n      }\n    }\n  });\n};\n","// ------------------------------\n// TABLE OF CONTENTS\n// ------------------------------\n// 1. Hooks\n//    - useRemoveTeamFromSeason\n//    - useUpdateTeamData\n//    - useAddNewTeamToSeason\n// 2. FireBaseFunctions\n//    - removeTeamFromSeasonRQ\n//    - updateTeamDataRQ\n//    - addNewTeamToSeasonRQ\n\n//------------------------\n// IMPORTS\n//------------------------\n\n// react-query\nimport { useMutation } from 'react-query';\nimport { updateSeasonRQ } from './seasonUpdateHooks';\nimport { fetchSeasonRQ } from './seasonFetchHooks';\nimport { removeAllPlayersFromTeamRQ } from './teamToPlayerOperations';\n\n//firebase\nimport { db } from '../../firebaseConfig';\nimport {\n  collection,\n  updateDoc,\n  deleteDoc,\n  doc,\n  runTransaction,\n} from 'firebase/firestore';\n\n// types\nimport { SeasonName, TeamId } from '../types/sharedTypes';\nimport { Team } from '../types/teamTypes';\n\nexport const createNewTeamData = (teamName: string, seasonId: SeasonName) => ({\n  teamName,\n  seasonId,\n  players: {\n    captain: {},\n    player2: {},\n    player3: {},\n    player4: {},\n    player5: {},\n  },\n  wins: 0,\n  losses: 0,\n  points: 0,\n});\n\n// ------------------------------\n// 1. HOOKS\n// ------------------------------\n\n/**\n * Hook to remove a team from a season.\n *\n * Calls removeTeamFromSeasonRQ to remove the team ID from the season's\n * team array. Also deletes the team document and removes teamId players documents.\n *\n * @param props - Optional config props for useMutation\n * @returns Object with removeTeam function and mutation result/methods\n */\n\nexport const useRemoveTeamFromSeason = () => {\n  const mutation = useMutation(removeTeamFromSeasonRQ);\n  const removeTeam = async (seasonName: SeasonName, teamId: TeamId) => {\n    try {\n      await mutation.mutateAsync({ seasonName, teamId });\n      if (mutation.isSuccess) {\n        await deleteTeamRQ(teamId);\n        await removeAllPlayersFromTeamRQ(teamId);\n      }\n    } catch (error) {\n      console.error('Error removing Team from Season', error);\n    }\n  };\n  return { removeTeam, ...mutation };\n};\n\nexport const useUpdateTeamData = () => {\n  return useMutation(updateTeamDataRQ);\n};\n\nexport const useAddNewTeamToSeason = () => {\n  return useMutation(addNewTeamToSeasonRQ);\n};\n// ------------------------------\n// 2. FIREBASE FUNCTIONS\n// ------------------------------\n\n/**\n * Removes a team from a season.\n *\n * @param seasonName - The name of the season to remove the team from.\n * @param teamId - The ID of the team to remove.\n *\n * Fetches the season, filters the team array to remove the given team ID,\n * and updates the season with the new team array.\n */\n\nconst removeTeamFromSeasonRQ = async ({\n  seasonName,\n  teamId,\n}: {\n  seasonName: SeasonName;\n  teamId: TeamId;\n}) => {\n  const season = await fetchSeasonRQ(seasonName);\n  if (!season) return;\n\n  const teamArray = season.teams;\n  const newArray = teamArray.filter((team) => team !== teamId);\n  await updateSeasonRQ({ seasonName, seasonData: { teams: newArray } });\n};\n\n/**\n * Updates the data for the team with the given ID.\n *\n * @param teamId - The ID of the team to update.\n * @param data - The new team data to update.\n */\nconst updateTeamDataRQ = async ({\n  teamId,\n  data,\n}: {\n  teamId: TeamId;\n  data: Team;\n}) => {\n  // Reference to the team document\n  const teamRef = doc(db, 'teams', teamId);\n  // Update team data\n  await updateDoc(teamRef, data);\n};\n\nconst deleteTeamRQ = async (teamId: TeamId) => {\n  const teamRef = doc(db, 'teams', teamId);\n  await deleteDoc(teamRef);\n};\n\n/**\n * Adds a new team to the given season.\n *\n * Creates a new team document with the provided name and season.\n * Gets the current team array for the season.\n * Adds the new team's ID to the array.\n * Updates the season document with the new team array.\n */\nconst addNewTeamToSeasonRQ = async ({\n  seasonName,\n  teamName,\n}: {\n  seasonName: SeasonName;\n  teamName: string;\n}) => {\n  await runTransaction(db, async (transaction) => {\n    // Reference to the season\n    const seasonRef = doc(db, 'seasons', seasonName);\n    const seasonDoc = await transaction.get(seasonRef);\n\n    // Ensure the season exists\n    if (!seasonDoc.exists()) {\n      throw new Error(`Season ${seasonName} not found`);\n    }\n\n    // Create a new team document reference with an ID\n    const teamRef = doc(collection(db, 'teams'));\n    const newTeamData = createNewTeamData(teamName, seasonName);\n    transaction.set(teamRef, newTeamData);\n\n    // Get the current teams array from the season document, if it exists\n    const currentTeams = seasonDoc.data().teams || [];\n\n    // Update the season document with the new team's ID\n    transaction.update(seasonRef, {\n      teams: [...currentTeams, teamRef.id],\n    });\n  });\n};\n","import { useState, useEffect } from 'react';\nimport { User, onAuthStateChanged } from 'firebase/auth';\nimport { auth } from '../../firebaseConfig';\n\nexport const useAuth = (): { user: User | null } => {\n  const [user, setUser] = useState<User | null>(null);\n\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {\n      setUser(currentUser);\n    });\n\n    return () => {\n      unsubscribe();\n    };\n  }, []);\n\n  return { user };\n};\n","import {\n  createUserWithEmailAndPassword,\n  sendEmailVerification,\n  signInWithEmailAndPassword,\n  sendPasswordResetEmail,\n  signOut,\n  onAuthStateChanged,\n  User,\n} from 'firebase/auth';\nimport { auth } from '../firebaseConfig';\nimport { Email } from './types/sharedTypes';\n\n/**\n * INDEX TABLE OF CONTENTS\n * 1. Enums\n * 2. User functions\n * 3. Password functions\n * 4. Email Functions\n * 5. Session Management Functions\n */\n\n// =======================================\n// 1. Enums\n// =======================================\n\n/**\n * @typedef {Object} MODES\n * @property {'login'} LOGIN - Represents the login page\n * @property {'register'} REGISTER - Represents the registration page\n * @property {'resetPassword'} RESET_PASSWORD - Represents the reset password page\n */\n\nexport const LOGIN_MODES = {\n  LOGIN: 'login',\n  REGISTER: 'register',\n  RESET_PASSWORD: 'resetPassword',\n};\n\n// =======================================\n// 2. User Functions\n// =======================================\n\n/** Register a user\n * @param {string} email users email\n * @param {string} password users password\n * @returns {object} User response object\n * @throws {Error} Throws an error if registration fails\n */\n\nexport const registerUser = async (email: Email, password: string) => {\n  try {\n    const response = await createUserWithEmailAndPassword(\n      auth,\n      email,\n      password\n    );\n    return response.user;\n  } catch (error) {\n    throw error;\n  }\n};\n\n/** Log in a user\n * @param {string} email users email\n * @param {string} password users password\n * @returns {object} User response object\n * @throws {Error} Throws an error if login fails\n */\n\nexport const loginUser = async (email: Email, password: string) => {\n  try {\n    const response = await signInWithEmailAndPassword(auth, email, password);\n    return response.user;\n  } catch (error) {\n    throw error;\n  }\n};\n\n/** Get current user\n * @returns {object} User response object\n */\n\nexport const getCurrentUser = () => auth.currentUser;\n\n// =======================================\n// 3. Password Functions\n// =======================================\n\n/** Sends a password email to the provided email address\n * @param {string} email users email\n * @returns {undefined}\n * @throws {Error} Throws an error if sending reset password email fails\n */\n\nexport const resetPassword = async (email: Email) => {\n  try {\n    await sendPasswordResetEmail(auth, email);\n    alert('Reset Password sent to your Email');\n  } catch (error) {\n    console.error('Error sending reset password email', error);\n    throw error;\n  }\n};\n\n// =======================================\n// 4. Email Functions\n// =======================================\n\n/** Sends verification email\n * @param {object} user Firebase user object\n * @returns {undefined}\n * @throws {Error} Throws an error if sending reset password email fails\n */\n\nexport const sendVerificationEmail = async (user: User) => {\n  try {\n    await sendEmailVerification(user);\n    console.log('Verification email sent.');\n  } catch (error) {\n    console.error('Error sending verification email:', error);\n    throw error;\n  }\n};\n\n// =======================================\n// 5. Session Management Functions\n// =======================================\n\n/** Logs out the current user\n * @returns {undefined}\n * @throws {Error} Throws and error if logout fails\n */\n\nexport const logoutUser = async () => {\n  try {\n    await signOut(auth);\n  } catch (error) {\n    console.error('Error signing out:', error);\n    throw error;\n  }\n};\n\n/** Subscribe to authentication state changes\n * @param {function} callback Callback function to handle auth state changes\n * @returns {function} Unsubscribe function\n */\n\nexport const observeAuthState = (callback: any) => {\n  return onAuthStateChanged(auth, callback);\n};\n"],"mappings":"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","names":["doc","doc","doc","useQuery","doc","getDoc","useQuery","doc","getDoc","useQuery","collection","doc","getDoc","getDocs","useQuery","doc","getDoc","getDocs","collection","useMutation","updateDoc","doc","useMutation","doc","updateDoc","useQuery","doc","getDoc","useQuery","query","doc","getDoc","useMutation","doc","updateDoc","getDoc","useMutation","doc","updateDoc","getDoc","useMutation","collection","updateDoc","doc","runTransaction","useMutation","doc","updateDoc","runTransaction","collection","onAuthStateChanged","onAuthStateChanged"]}